[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IS415-GAA",
    "section": "",
    "text": "Welcome to IS415 Geospatial Analytics and Applications.\nThis is the course website of IS415 I study this term. You will find my course work on this website.\nThank You very much."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "IS415_GAA",
    "section": "",
    "text": "--- title: “About” ---"
  },
  {
    "objectID": "Hands_On_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands_On_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands On Exercise 01",
    "section": "",
    "text": "Hands On\n\npacman::p_load(tidyverse, sf)\n\nmpsz <- st_read(dsn = \"./data/geospatial\",\n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/Hands_On_Ex/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall"
  },
  {
    "objectID": "Hands_On_Ex/Hands_On_Ex01/Hands_On_Ex01.html",
    "href": "Hands_On_Ex/Hands_On_Ex01/Hands_On_Ex01.html",
    "title": "Hands On Exercise 01",
    "section": "",
    "text": "#  eval:  false\n\npacman::p_load(tidyverse, sf)\n\nmpsz <- st_read(dsn = \"./data/geospatial\",\n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/Hands_On_Ex/Hands_On_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\nplot(mpsz)"
  },
  {
    "objectID": "InClass/InClassWeek2/InClass2.html",
    "href": "InClass/InClassWeek2/InClass2.html",
    "title": "IS415_GAA",
    "section": "",
    "text": "pacman::p_load(sf, tidyverse, funModeling)\n\nNGA <- st_read(\"./Data/geospatial/\",\n               layer = \"nga_admbnda_adm2_osgof_20190417\") %>%\nst_transform(crs = 26392)\n\nReading layer `nga_admbnda_adm2_osgof_20190417' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/InClass/InClassWeek2/Data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\nwp_nga <- read_csv(\"./Data/aspatial/WPdx.csv\") %>%\nfilter(`#clean_country_name` == \"Nigeria\")\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n\n\nRows: 426774 Columns: 74\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (46): #source, #report_date, #status_id, #water_source_clean, #water_sou...\ndbl (23): row_id, #lat_deg, #lon_deg, #install_year, #fecal_coliform_value, ...\nlgl  (5): #rehab_year, #rehabilitator, is_urban, latest_record, is_duplicate\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)\n\n\nwp_sf <- st_sf(wp_nga, crs=4326)\nwp_sf <- wp_sf %>%st_transform(crs = 26392)\n\nNGA <- NGA %>%select(c(3:4, 8:9))\nNGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]\n\n[1] \"Bassa\"    \"Ifelodun\" \"Irepodun\" \"Nasarawa\" \"Obi\"      \"Surulere\"\n\nNGA$ADM2_EN[94] <- \"Bassa, Kogi\"\nNGA$ADM2_EN[95] <- \"Bassa, Plateau\"\nNGA$ADM2_EN[304] <- \"Ifelodun, Kwara\"\nNGA$ADM2_EN[305] <- \"Ifelodun, Osun\"\nNGA$ADM2_EN[355] <- \"Irepodun, Kwara\"\nNGA$ADM2_EN[356] <- \"Irepodun, Osun\"\nNGA$ADM2_EN[519] <- \"Nasarawa, Kano\"\nNGA$ADM2_EN[520] <- \"Nasarawa, Nasarawa\"\nNGA$ADM2_EN[546] <- \"Obi, Benue\"\nNGA$ADM2_EN[547] <- \"Obi, Nasarawa\"\nNGA$ADM2_EN[693] <- \"Surulere, Lagos\"\nNGA$ADM2_EN[694] <- \"Surulere, Oyo\"\n\n\nNGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]\n\ncharacter(0)\n\n\n\nfreq(data = wp_sf,\n     input = '#status_clean')\n\nWarning: The `<scale>` argument of `guides()` cannot be `FALSE`. Use \"none\" instead as\nof ggplot2 3.3.4.\nℹ The deprecated feature was likely used in the funModeling package.\n  Please report the issue at <\u001b]8;;https://github.com/pablo14/funModeling/issues\u0007https://github.com/pablo14/funModeling/issues\u001b]8;;\u0007>.\n\n\n\n\n\n                      #status_clean frequency percentage cumulative_perc\n1                        Functional     47228      48.45           48.45\n2                    Non-Functional     30638      31.43           79.88\n3                              <NA>     10154      10.42           90.30\n4          Functional, needs repair      4792       4.92           95.22\n5               Non-Functional, dry      2473       2.54           97.76\n6            Functional, not in use      1775       1.82           99.58\n7          Abandoned/Decommissioned       321       0.33           99.91\n8         Functional but not in use        86       0.09          100.00\n9  Non-Functional due to dry season         7       0.01          100.01\n10      Functional but needs repair         4       0.00          100.00\n\n\n\nwp_sf_nga <- wp_sf %>% \n  rename(status_clean = '#status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = replace_na(\n    status_clean, \"unknown\"))\n\n\n\nwp_functional <- wp_sf_nga %>%\n  filter(status_clean %in%\n           c(\"Functional\",\n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n\n\nwp_nonfunctional <- wp_sf_nga %>%\n  filter(status_clean %in%\n           c(\"Abandoned/Decommissioned\",\n             \"Abandoned\",\n             \"Non-Functional due to dry season\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\"))\n\n\nwp_unknown <- wp_sf_nga %>%\n  filter(status_clean == \"unknown\")\n\n\nNGA_wp <- NGA %>% \n  mutate(`total_wp` = lengths(\n    st_intersects(NGA, wp_sf_nga))) %>%\n  mutate(`wp_functional` = lengths(\n    st_intersects(NGA, wp_functional))) %>%\n  mutate(`wp_nonfunctional` = lengths(\n    st_intersects(NGA, wp_nonfunctional))) %>%\n  mutate(`wp_unknown` = lengths(\n    st_intersects(NGA, wp_unknown)))\n\n\n\nggplot(data = NGA_wp,\n       aes(x = total_wp)) + \n  geom_histogram(bins=20,\n                 color=\"black\",\n                 fill=\"light blue\") +\n  geom_vline(aes(xintercept=mean(\n    total_wp, na.rm=T)),\n             color=\"red\", \n             linetype=\"dashed\", \n             size=0.8) +\n  ggtitle(\"Distribution of total water points by LGA\") +\n  xlab(\"No. of water points\") +\n  ylab(\"No. of\\nLGAs\") +\n  theme(axis.title.y=element_text(angle = 0))\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\nwrite_rds(NGA_wp, \"./Data/NGA_wp.rds\")"
  },
  {
    "objectID": "InClass/InClassWeek2/inclasstest2.html",
    "href": "InClass/InClassWeek2/inclasstest2.html",
    "title": "IS415_GAA",
    "section": "",
    "text": "pacman::p_load(sf, tidyverse, funModeling)\n\n\n\nwp_nga <- read_csv(\"Data/aspatial/WPdx.csv\") %>%\nfilter(`#clean_country_name` == \"Nigeria\")\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n\n\nRows: 426774 Columns: 74\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (46): #source, #report_date, #status_id, #water_source_clean, #water_sou...\ndbl (23): row_id, #lat_deg, #lon_deg, #install_year, #fecal_coliform_value, ...\nlgl  (5): #rehab_year, #rehabilitator, is_urban, latest_record, is_duplicate\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "InClass/InClassWeek3/InClass3.html",
    "href": "InClass/InClassWeek3/InClass3.html",
    "title": "IS415_GAA",
    "section": "",
    "text": "pacman::p_load(tmap, tidyverse, sf)\n\n\nNGA_wp <- read_rds(\"data/rds/NGA_wp.rds\")\np1 <- tm_shape(NGA_wp) +\n  tm_fill(\"wp_functional\",\n          n = 10,\n          style = \"equal\",\n          palette = \"Blues\") +\n  tm_borders(lwd = 0.1,\n             alpha = 1) +\n  tm_layout(main.title = \"Distribution of functional water point by LGAs\",\n            legend.outside = FALSE)\n\n\np2 <- tm_shape(NGA_wp) +\n  tm_fill(\"total_wp\",\n          n = 10,\n          style = \"equal\",\n          palette = \"Blues\") +\n  tm_borders(lwd = 0.1,\n             alpha = 1) +\n  tm_layout(main.title = \"Distribution of total  water point by LGAs\",\n            legend.outside = FALSE)\n\n\ntmap_arrange(p2, p1, nrow = 1)\n\n\n\n\n\nNGA_wp <- NGA_wp %>%\n  mutate(pct_functional = wp_functional/total_wp) %>%\n  mutate(pct_nonfunctional = wp_nonfunctional/total_wp)\n\n\ntm_shape(NGA_wp) +\n  tm_fill(\"pct_functional\",\n          n = 10,\n          style = \"equal\",\n          palette = \"Blues\",\n          legend.hist = TRUE) +\ntm_borders(lwd = 0.1,\n             alpha = 1) +\ntm_layout(main.title = \"Rate map of functional water point by LGAs\",\n            legend.outside = TRUE)\n\n\n\n\n\nNGA_wp <- NGA_wp %>%\n  drop_na()\n\npercent <- c(0,.01,.1,.5,.9,.99,1)\nvar <- NGA_wp[\"pct_functional\"] %>%\n  st_set_geometry(NULL)\nquantile(var[,1], percent)\n\n        0%         1%        10%        50%        90%        99%       100% \n0.00000000 0.01818182 0.18181818 0.41666667 0.76086957 1.00000000 1.00000000 \n\nget.var <- function(vname,df) {\n  v <- df[vname] %>% \n    st_set_geometry(NULL)\n  v <- unname(v[,1])\n  return(v)\n}\n\n\npercentmap <- function(vnam, df, legtitle=NA, mtitle=\"Percentile Map\"){\n  percent <- c(0,.01,.1,.5,.9,.99,1)\n  var <- get.var(vnam, df)\n  bperc <- quantile(var, percent)\n  tm_shape(df) +\n  tm_polygons() +\n  tm_shape(df) +\n     tm_fill(vnam,\n             title=legtitle,\n             breaks=bperc,\n             palette=\"Blues\",\n          labels=c(\"< 1%\", \"1% - 10%\", \"10% - 50%\", \"50% - 90%\", \"90% - 99%\", \"> 99%\"))  +\n  tm_borders() +\n  tm_layout(main.title = mtitle, \n            title.position = c(\"right\",\"bottom\") , legend.outside = TRUE)\n}\n\npercentmap(\"total_wp\", NGA_wp)\n\n\n\n\n\nboxbreaks <- function(v,mult=1.5) {\n  qv <- unname(quantile(v))\n  iqr <- qv[4] - qv[2]\n  upfence <- qv[4] + mult * iqr\n  lofence <- qv[2] - mult * iqr\n  # initialize break points vector\n  bb <- vector(mode=\"numeric\",length=7)\n  # logic for lower and upper fences\n  if (lofence < qv[1]) {  # no lower outliers\n    bb[1] <- lofence\n    bb[2] <- floor(qv[1])\n  } else {\n    bb[2] <- lofence\n    bb[1] <- qv[1]\n  }\n  if (upfence > qv[5]) { # no upper outliers\n    bb[7] <- upfence\n    bb[6] <- ceiling(qv[5])\n  } else {\n    bb[6] <- upfence\n    bb[7] <- qv[5]\n  }\n  bb[3:5] <- qv[2:4]\n  return(bb)\n}\n\n\nget.var <- function(vname,df) {\n  v <- df[vname] %>% st_set_geometry(NULL)\n  v <- unname(v[,1])\n  return(v)\n}\n\nvar <- get.var(\"wp_nonfunctional\", NGA_wp) \nboxbreaks(var)\n\n[1] -53.5   0.0  14.0  34.0  59.0 126.5 252.0\n\nboxmap <- function(vnam, df, \n                   legtitle=NA,\n                   mtitle=\"Box Map\",\n                   mult=1.5){\n  var <- get.var(vnam,df)\n  bb <- boxbreaks(var)\n  tm_shape(df) +\n    tm_polygons() +\n  tm_shape(df) +\n     tm_fill(vnam,title=legtitle,\n             breaks=bb,\n             palette=\"Blues\",\n          labels = c(\"lower outlier\", \n                     \"< 25%\", \n                     \"25% - 50%\", \n                     \"50% - 75%\",\n                     \"> 75%\", \n                     \"upper outlier\"))  +\n  tm_borders() +\n  tm_layout(main.title = mtitle, \n            title.position = c(\"left\",\n                               \"top\") , legend.outside = TRUE )\n}\n\n\n\ntmap_mode(\"plot\")\n\ntmap mode set to plotting\n\nboxmap(\"wp_nonfunctional\", NGA_wp)\n\nWarning: Breaks contains positive and negative values. Better is to use\ndiverging scale instead, or set auto.palette.mapping to FALSE."
  },
  {
    "objectID": "Take Home Assignment/TakeHome1.html",
    "href": "Take Home Assignment/TakeHome1.html",
    "title": "IS415_GAA",
    "section": "",
    "text": "##Loading required modules\npacman::p_load(sf, funModeling,maptools,raster, spatstat, tmap ,  tidyverse,sfdep ,  knitr) \n\n\nAbove we have imported all the relevant modules and now we will be importing all the relevant Data.\n\nHere we are importing the Nigeria adm data and removing any duplicates and filtering our data to only include our area of study, Osun state.\n\n\nNGA <- st_read(\"./data/geospatial/\",\n               layer = \"nga_admbnda_adm2_osgof_20190417\") %>%\nst_transform(crs = 26392)\n\nReading layer `nga_admbnda_adm2_osgof_20190417' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/Take Home Assignment/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\nNGA <- NGA %>%dplyr::select(c(3:4, 8:9))\nNGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]\n\n[1] \"Bassa\"    \"Ifelodun\" \"Irepodun\" \"Nasarawa\" \"Obi\"      \"Surulere\"\n\nNGA$ADM2_EN[94] <- \"Bassa, Kogi\"\nNGA$ADM2_EN[95] <- \"Bassa, Plateau\"\nNGA$ADM2_EN[304] <- \"Ifelodun, Kwara\"\nNGA$ADM2_EN[305] <- \"Ifelodun, Osun\"\nNGA$ADM2_EN[355] <- \"Irepodun, Kwara\"\nNGA$ADM2_EN[356] <- \"Irepodun, Osun\"\nNGA$ADM2_EN[519] <- \"Nasarawa, Kano\"\nNGA$ADM2_EN[520] <- \"Nasarawa, Nasarawa\"\nNGA$ADM2_EN[546] <- \"Obi, Benue\"\nNGA$ADM2_EN[547] <- \"Obi, Nasarawa\"\nNGA$ADM2_EN[693] <- \"Surulere, Lagos\"\nNGA$ADM2_EN[694] <- \"Surulere, Oyo\"\n\n\nNGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]\n\ncharacter(0)\n\nNGA<-NGA %>%filter(`ADM1_EN` == \"Osun\")\n\nNow we are going to import our Water Point Data and filter it to only include Osun state and applying the right projection system to our data.\n\nwp_nga <- read_csv(\"./data/aspatial/WPdx.csv\") %>%\nfilter(`#clean_country_name` == \"Nigeria\")\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n\n\nRows: 426774 Columns: 74\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (46): #source, #report_date, #status_id, #water_source_clean, #water_sou...\ndbl (23): row_id, #lat_deg, #lon_deg, #install_year, #fecal_coliform_value, ...\nlgl  (5): #rehab_year, #rehabilitator, is_urban, latest_record, is_duplicate\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwp_nga <- wp_nga %>%filter(`#clean_adm1` == \"Osun\")\nwp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)\nwp_sf <- st_sf(wp_nga, crs=4326)\nwp_sf <- wp_sf %>%st_transform(crs = 26392)\n\nNow we remove our “Unknown” values in the #status_clean column and create two sf’s called Functional and Non-Functional based on the filterings below.\n\n\n\n\n\n\n\nwp_sf_nga <- wp_sf %>%\n  rename(status_clean = '#status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = replace_na(\n    status_clean, \"unknown\"))\n\n\nwp_functional <- wp_sf_nga %>%\n  filter(status_clean %in%\n           c(\"Functional\",\n             \"Functional, needs repair\",\n             \"Functional, not in use\",\n             \"Functional but not in use\"))\n\n\nwp_nonfunctional <- wp_sf_nga %>%\n  filter(status_clean %in%\n           c(\"Abandoned/Decommissioned\",\n             \"Non-Functional, dry\",\n             \"Non-Functional\"))\n\nThe code chunk below uses as_Spatial() of sf package to convert the three geospatial data from simple feature data frame to sp’s Spatial* class.\n\nNGA_spatial <- as_Spatial(NGA)\nwp_spatial_functional <- as_Spatial(wp_functional)\nwp_spatial_non_functional <- as_Spatial(wp_nonfunctional)\n\nspatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial* classes into ppp object. We need to convert the Spatial classes* into Spatial object first.\nThe codes chunk below converts the Spatial* classes into generic sp objects.\n\nwp_sp_functional <- as(wp_spatial_functional, \"SpatialPoints\")\nwp_sp_non_functional <- as(wp_spatial_non_functional, \"SpatialPoints\")\nNGA_sp <- as(NGA_spatial, \"SpatialPolygons\")\n\nNow, we will use as.ppp() function of spatstat to convert the spatial data into spatstat’s ppp object format.\n\nwp_functional_ppp <- as(wp_sp_functional, \"ppp\")\nwp_non_functional_ppp <- as(wp_sp_non_functional, \"ppp\")\n\nNow we check for duplicates\n\nsum(multiplicity(wp_functional_ppp) > 1)\n\n[1] 0\n\nsum(multiplicity(wp_non_functional_ppp) > 1)\n\n[1] 0\n\n\nWhen analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region. so let’s convert NGA into the Owin format’\n\nNGA_owin <- as(NGA_sp, \"owin\")\nplot(NGA_owin)\n\n\n\n\nIn this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code chunk below.\n\nwp_functional_NGA_ppp = wp_functional_ppp[NGA_owin]\nwp_non_functional_NGA_ppp = wp_non_functional_ppp[NGA_owin]\n\nIn the code chunk below, rescale() is used to covert the unit of measurement from meter to kilometer.\n\nwp_functional_NGA_ppp <- rescale(wp_functional_NGA_ppp, 1000, \"km\")\nwp_non_functional_NGA_ppp <- rescale(wp_non_functional_NGA_ppp, 1000, \"km\")\n\nNow, we can run density() using the resale data set and plot the output kde map\n\nHere is the KDE map for Functional waterpoints\n\nkde_functional_wpNGA_bw <- density(wp_functional_NGA_ppp,\n                              sigma=bw.diggle,\n                              edge=TRUE,\n                            kernel=\"gaussian\") \n\nplot(kde_functional_wpNGA_bw)\n\n\n\n\nHere is the KDE map for Non-Functional Waterpoints.\n\nkde_non_functional_wpNGA_bw <- density(wp_non_functional_NGA_ppp, sigma=bw.diggle, edge=TRUE, kernel=\"gaussian\")\nplot(kde_non_functional_wpNGA_bw)\n\n\n\ngridded_kde_non_functional_wpNGA.bw<- as.SpatialGridDataFrame.im(kde_non_functional_wpNGA_bw)\n\nNow we convert each of the above KDE outputs into grid objects\nFor Functional Waterpoints :\nAs shown below we observe spots of highly density areas with Non Functional waterpoints meaning that the distribution of Non Functional Waterpoints in Osun are not randomly distributed.\n\ngridded_kde_functional_wpNGA.bw<- as.SpatialGridDataFrame.im(kde_functional_wpNGA_bw)\nplot(gridded_kde_functional_wpNGA.bw)\n\n\n\n\nFor Non Functional Waterpoints :\nAs shown below we observe spots of highly density areas with Non Functional waterpoints meaning that the distribution of Non Functional Waterpoints in Osun are not randomly distributed.\n\ngridded_kde_non_functional_wpNGA.bw<- as.SpatialGridDataFrame.im(kde_non_functional_wpNGA_bw)\nplot(gridded_kde_non_functional_wpNGA.bw)\n\n\n\n\nNext, we will convert the gridded kernal density objects into RasterLayer object by using raster() of raster package. Note that we need to re-declare the CRS information as converting our data to OWIN format removed this information.\nOnly then can we display the raster in cartographic quality map using tmap package.\nFor Non Functional Waterpoints :\n\ngridded_kde_non_functional_wpNGA.bw_raster <- raster(gridded_kde_non_functional_wpNGA.bw)\n\n\nprojection(gridded_kde_non_functional_wpNGA.bw_raster) <- CRS(\"+init=EPSG:26392 +datum=WGS84 +units=km\")\ngridded_kde_non_functional_wpNGA.bw_raster\n\nclass      : RasterLayer \ndimensions : 128, 128, 16384  (nrow, ncol, ncell)\nresolution : 0.8948485, 0.9616045  (x, y)\nextent     : 176.5032, 291.0438, 331.4347, 454.5201  (xmin, xmax, ymin, ymax)\ncrs        : +init=EPSG:26392 +datum=WGS84 +units=km \nsource     : memory\nnames      : v \nvalues     : -4.551756e-15, 20.49412  (min, max)\n\ntmap_mode('view') \n\ntmap mode set to interactive viewing\n\ntm_basemap(\"OpenStreetMap\") \n\n\n\n\ntm_shape(gridded_kde_non_functional_wpNGA.bw_raster) + \n  tm_raster(\"v\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"), frame = FALSE)\n\nlegend.postion is used for plot mode. Use view.legend.position in tm_view to set the legend position in view mode.\n\n\nVariable(s) \"v\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\nFor Functional Waterpoints :\n\ngridded_kde_functional_wpNGA.bw_raster <- raster(gridded_kde_functional_wpNGA.bw)\n\n\nprojection(gridded_kde_functional_wpNGA.bw_raster) <- CRS(\"+init=EPSG:26392 +datum=WGS84 +units=km\")\ngridded_kde_functional_wpNGA.bw_raster\n\nclass      : RasterLayer \ndimensions : 128, 128, 16384  (nrow, ncol, ncell)\nresolution : 0.8948485, 0.9616045  (x, y)\nextent     : 176.5032, 291.0438, 331.4347, 454.5201  (xmin, xmax, ymin, ymax)\ncrs        : +init=EPSG:26392 +datum=WGS84 +units=km \nsource     : memory\nnames      : v \nvalues     : -4.599238e-15, 24.34507  (min, max)\n\ntmap_mode('view') \n\ntmap mode set to interactive viewing\n\ntm_basemap(\"OpenStreetMap\") \n\n\n\n\ntm_shape(gridded_kde_functional_wpNGA.bw_raster) + \n  tm_raster(\"v\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\"), frame = FALSE)\n\nlegend.postion is used for plot mode. Use view.legend.position in tm_view to set the legend position in view mode.\n\n\nVariable(s) \"v\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n#Part 1 Done\n\nNow we are going to compute L-function estimation by using Lest() of spatstat package. W will also how to perform monta carlo simulation test using envelope() of spatstat package.\n\n\nL_osun_functional = Lest(wp_functional_NGA_ppp, correctionc = \"Ripley\")\nplot(L_osun_functional, . -r ~ r, \n     ylab= \"L(d)-r\", xlab = \"d(km)\")\n\n\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\nHo = The distribution of Functional Waterpoints in Osun are randomly distributed.\nH1= The distribution of Functional Waterpoints in Osun are not randomly distributed.\nThe null hypothesis will be rejected if p-value if smaller than alpha value of 0.05. Confidence interval is therefore 95%\nThe code chunk below is used to perform the hypothesis testing.\n\nL_osun_functional.csr <- envelope(wp_functional_NGA_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)\n\nGenerating 39 simulations of CSR  ...\n1, 2,  [etd 1:22:19] 3,  [etd 1:24:48] 4,\n [etd 1:22:18] 5,  [etd 1:19:36] 6,  [etd 1:17:10] 7,  [etd 1:15:01] 8,\n [etd 1:12:31] 9,  [etd 1:10:13] 10,  [etd 1:07:59] 11,  [etd 1:05:33] 12,\n [etd 1:02:40] 13,  [etd 1:00:45] 14,  [etd 58:25] 15,  [etd 56:00] 16,\n [etd 53:53] 17,  [etd 51:35] 18,  [etd 49:23] 19,  [etd 47:01] 20,\n [etd 44:46] 21,  [etd 42:29] 22,  [etd 40:09] 23,  [etd 37:46] 24,\n [etd 35:22] 25,  [etd 33:02] 26,  [etd 30:43] 27,  [etd 28:21] 28,\n [etd 25:57] 29,  [etd 23:34] 30,  [etd 21:13] 31,  [etd 18:50] 32,\n [etd 16:28] 33,  [etd 14:09] 34,  [etd 11:48] 35,  [etd 9:24] 36,\n [etd 7:03] 37,  [etd 4:43] 38,  [etd 2:22]  39.\n\nDone.\n\n\n\nplot(L_osun_functional.csr, . - r ~ r, xlab=\"d\", ylab=\"L(d)-r\")\n\n\n\n\nBased on the output of CSR as shown above, the curve is above envelope as such we have enough statisctial evidence to reject the null hypothesis at 95% confidence. Therefore we can say that that the distribution of Functional waterpoints are not randomly distributed with 95% confidence.\n\nL_osun_non_functional = Lest(wp_non_functional_NGA_ppp, correctionc = \"Ripley\")\nplot(L_osun_non_functional, . -r ~ r, ylab= \"L(d)-r\", xlab = \"d(km)\")\n\n\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\nHo = The distribution of Non Functional Waterpoints in Osun are randomly distributed.\nH1= The distribution of Non Functional Waterpoints in Osun are not randomly distributed.\nThe null hypothesis will be rejected if p-value if smaller than alpha value of 0.05. Confidence interval is therefore 95%\nThe code chunk below is used to perform the hypothesis testing.\n\nL_osun_non_functional.csr <- envelope(wp_non_functional_NGA_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE)\n\nGenerating 39 simulations of CSR  ...\n1, 2,  [etd 59:34] 3,  [etd 58:46] 4,\n [etd 56:54] 5,  [etd 53:58] 6,  [etd 52:31] 7,  [etd 50:27] 8,\n [etd 49:57] 9,  [etd 48:12] 10,  [etd 46:21] 11,  [etd 44:51] 12,\n [etd 43:34] 13,  [etd 41:53] 14,  [etd 40:07] 15,  [etd 38:11] 16,\n [etd 36:26] 17,  [etd 34:30] 18,  [etd 33:00] 19,  [etd 31:19] 20,\n [etd 29:41] 21,  [etd 28:00] 22,  [etd 26:27] 23,  [etd 24:57] 24,\n [etd 23:29] 25,  [etd 21:55] 26,  [etd 20:24] 27,  [etd 18:47] 28,\n [etd 17:13] 29,  [etd 15:39] 30,  [etd 14:28] 31,  [etd 12:49] 32,\n [etd 11:11] 33,  [etd 9:35] 34,  [etd 7:59] 35,  [etd 6:24] 36,\n [etd 4:47] 37,  [etd 3:11] 38,  [etd 1:35]  39.\n\nDone.\n\nplot(L_osun_non_functional.csr, . - r ~ r, xlab=\"d\", ylab=\"L(d)-r\")\n\n\n\n\nBased on the output of CSR as shown above, the curve is above envelope as such we have enough statisctial evidence to reject the null hypothesis at 95% confidence. Therefore we can say that that the distribution of Non Functional waterpoints are not randomly distributed with 95% confidence.\nAdvantages of kernel density maps over point maps are as follows:\n\nSmoothing: Kernel density maps can smooth out spatial patterns in the data and reveal underlying trends that might not be apparent in a point map. This can be especially useful when the data is dense or there is a lot of variability in the data.\nArea representation: Kernel density maps represent the intensity of data over an area rather than just at specific locations. This makes it easier to see patterns in the data and to make generalizations about the distribution of the data.\nHandling of sparse data: Kernel density maps can be useful for visualizing sparse data that is spread out over a large area. In a point map, the sparse data might not be noticeable, whereas in a kernel density map, it can be easily seen as a low intensity area.\nImproved readability: Kernel density maps can be easier to read and interpret than point maps, especially when the data is dense or there are many overlapping points. In a kernel density map, the data is represented as a continuous surface, which can make it easier to see patterns and relationships in the data.\n\nFor part 3 we are going to reload our wp data as it will require different kind of manipulation from the start. We also need some different modules\n\npacman::p_load(sf, funModeling,maptools,raster, spatstat, tmap ,  tidyverse,sfdep) \n\n\nwp_nga <- read_csv(\"./data/aspatial/WPdx.csv\") %>%\nfilter(`#clean_country_name` == \"Nigeria\")\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n\n\nRows: 426774 Columns: 74\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (46): #source, #report_date, #status_id, #water_source_clean, #water_sou...\ndbl (23): row_id, #lat_deg, #lon_deg, #install_year, #fecal_coliform_value, ...\nlgl  (5): #rehab_year, #rehabilitator, is_urban, latest_record, is_duplicate\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwp_nga <- wp_nga %>%filter(`#clean_adm1` == \"Osun\")\nwp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)\n\n\nwp_sf <- st_sf(wp_nga, crs=4326)\nwp_sf <- wp_sf %>%st_transform(crs = 26392)\n\nWe are going to ensure that we only have two types of variables in #status_clean. We will drop those that are not labelled (NA) and then rename the rest to functional and non-functional where appropriate\n\nwp_sf_nga <- wp_sf %>% \n  rename(status_clean = '#status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = str_replace(status_clean, \"Functional, needs repair\", \"Functional\"))\n\nwp_sf_nga <- wp_sf_nga %>% \n  rename(status_clean = 'status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = str_replace(status_clean, \"Functional, not in use\", \"Functional\"))\n\n\nwp_sf_nga <- wp_sf_nga %>% \n  rename(status_clean = 'status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = str_replace(status_clean, \"Functional but not in use\", \"Functional\"))\n\n\n\n\nwp_sf_nga <- wp_sf_nga %>% \n  rename(status_clean = 'status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = str_replace(status_clean, \"Non-Functional, dry\", \"Non-Functional\"))\n\n\nwp_sf_nga <- wp_sf_nga %>% \n  rename(status_clean = 'status_clean') %>%\n  select(status_clean) %>%\n  mutate(status_clean = str_replace(status_clean, \"Abandoned/Decommissioned\", \"Non-Functional\"))\n\n\n\nwp_sf_nga <- wp_sf_nga %>%drop_na('status_clean')\n\n\n#Successful renaming\nunique(wp_sf_nga$status_clean)\n\n[1] \"Functional\"     \"Non-Functional\"\n\n\n\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\ntm_shape(NGA) +\n  tm_polygons() +\ntm_shape(wp_sf_nga)+ \n  tm_dots(col = \"status_clean\",\n             size = 0.01,\n             border.col = \"black\",\n             border.lwd = 0.5) \n\n\n\n\n\n\nIn the code chunk below, st_knn() of sfdep package is used to determine the k (i.e. 6) nearest neighbours for given point geometry.\n\nnb <- include_self(\n  st_knn(st_geometry(wp_sf_nga), 6))\n\nComputing kernel weights : In the code chunk below, st_kernel_weights() of sfdep package is used to derive a weights list by using a kernel function.\n\nwt <- st_kernel_weights(nb, \n                        wp_sf_nga, \n                        \"gaussian\", \n                        adaptive = TRUE)\n\nTo compute LCLQ by using sfdep package, the reference point data must be in either character or vector list. The code chunks below are used to prepare two vector lists.One of Functional and for Non-Functional and are called A and B respectively.\n\nFunctional <- wp_sf_nga %>%\n  filter(status_clean == \"Functional\")\nA <- Functional$status_clean\n\n\nNonFunctional <- wp_sf_nga %>%\n  filter(status_clean == \"Non-Functional\")\nB <- NonFunctional$status_clean\n\nIn the code chunk below local_colocation() us used to compute the LCLQ values for Functional point event.\n\nLCLQ <- local_colocation(A, B, nb, wt, 39)\n\nBefore we can plot the LCLQ values their p-values, we need to join the output of local_colocation() to the stores sf data.frame. However, a quick check of LCLQ data-frame, we can’t find any field can be used as the join field. As a result, cbind() of Base R is useed.\n\nLCLQ_wp <- cbind(wp_sf_nga, LCLQ) \n\nIn the code chunk below, tmap functions are used to plot the LCLQ analysis.\n\ntmap_mode(\"view\")\n\ntmap mode set to interactive viewing\n\ntm_shape(NGA) +\n  tm_polygons() +\ntm_shape(LCLQ_wp)+ \n  tm_dots(col = \"Non.Functional\",\n             size = 0.01,\n             border.col = \"black\",\n             border.lwd = 0.5) \n\n\n\n\n\n\nIn order to conduct leve 2 spatial analysis we need to conver our data to PPP format as shown below\n\nLCLQ_ppp  <- as_Spatial(LCLQ_wp)\nLCLQ_ppp <- as(LCLQ_ppp, \"SpatialPoints\")\nLCLQ_ppp <- as(LCLQ_ppp, \"ppp\")\nLCLQ_ppp\n\nPlanar point pattern: 4997 points\nwindow: rectangle = [177285.9, 290750.96] x [340054.1, 450859.7] units\n\n\nH0 = The spatial distribution of functional and non-functional water points are independent from each other.}\nH1 = The spatial distribution of functional and non-functional water points are [not]{. underline} independent from each other.\nThe null hypothesis will be rejected if p-value if smaller than alpha value of 0.05. Confidence interval is therefore 95%\nThe code chunk below is used to perform the hypothesis testing.\n\nplot(envelope(LCLQ_ppp, Lest, nsim = 39, rank = 1, glocal=TRUE))\n\nGenerating 39 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  39.\n\nDone.\n\n\n\n\n\nBased on the output of CSR as shown above, the curve is above envelope as such we have enough statisctial evidence to reject the null hypothesis at 95% confidence. he spatial distribution of functional and non-functional water points are not independent from each other with 95% confidence"
  },
  {
    "objectID": "InClass/InClassWeek4/InClassWeek4.html",
    "href": "InClass/InClassWeek4/InClassWeek4.html",
    "title": "IS415_GAA",
    "section": "",
    "text": "pacman::p_load(maptools, sf, raster, spatstat, tmap)\n\n\nchildcare_sf <- st_read(\"data/child-care-services-geojson.geojson\") %>%\n  st_transform(crs = 3414)\n\nReading layer `child-care-services-geojson' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/InClass/InClassWeek4/data/child-care-services-geojson.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 1545 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\nsg_sf <- st_read(dsn = \"data\", \n                 layer=\"CostalOutline\")\n\nReading layer `CostalOutline' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/InClass/InClassWeek4/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 60 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2663.926 ymin: 16357.98 xmax: 56047.79 ymax: 50244.03\nProjected CRS: SVY21\n\n\n\nmpsz_sf <- st_read(dsn = \"data\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/shaythuram/Desktop/Geospatial Analytics and Applications/Content/QUARTO SITE/InClass/InClassWeek4/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21"
  }
]